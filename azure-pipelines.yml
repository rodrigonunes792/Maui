trigger:
- main

pool:
  vmImage: windows-latest

variables:
  buildConfiguration: 'Release'
  # Defina o caminho correto para sua solução
  solutionPath: '**/*.sln'  # Busca por qualquer arquivo .sln
  # Ou use o caminho específico se souber onde está:
  # solutionPath: 'Contagem_V1/Contagem.sln'

steps:
# Primeiro, vamos listar os arquivos para debug
- task: PowerShell@2
  displayName: 'List files for debugging'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Listing files in repository root:"
      Get-ChildItem -Recurse -Name "*.sln" | ForEach-Object { Write-Host $_ }
      Write-Host "Current directory contents:"
      Get-ChildItem -Recurse | Where-Object { $_.Name -like "*.sln" -or $_.Name -like "*.csproj" } | Select-Object FullName

- task: UseDotNet@2
  displayName: 'Use .NET SDK 7.0.x'  # Voltando para .NET 7 se o projeto usar
  inputs:
    version: '7.0.x'
    includePreviewVersions: false

- task: DotNetCoreCLI@2
  displayName: 'Install MAUI Workload'
  inputs:
    command: 'custom'
    custom: 'workload'
    arguments: 'install maui'

- task: DotNetCoreCLI@2
  displayName: 'Restore dependencies'
  inputs:
    command: 'restore'
    projects: '$(solutionPath)'
    # Adicione verbosidade para debug
    arguments: '--verbosity normal'

# Restore específico para o projeto MAUI com target Android
- task: DotNetCoreCLI@2
  displayName: 'Restore MAUI project for Android'
  inputs:
    command: 'restore'
    projects: '**/*Contagem*.csproj'  # Padrão mais amplo
    arguments: '--verbosity normal'

# Verificar target frameworks disponíveis
- task: PowerShell@2
  displayName: 'Check project target frameworks'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Current working directory:"
      pwd
      Write-Host "Listing all directories and files:"
      Get-ChildItem -Recurse | Where-Object { $_.Name -like "*.csproj" } | ForEach-Object {
        Write-Host "Found project file: $($_.FullName)"
      }
      
      Write-Host "Searching for SoftwareShow.Contagem.MApp.csproj:"
      $projFiles = Get-ChildItem -Recurse -Filter "SoftwareShow.Contagem.MApp.csproj"
      
      if ($projFiles.Count -gt 0) {
        foreach ($projFile in $projFiles) {
          Write-Host "Found project: $($projFile.FullName)"
          Write-Host "Project file content:"
          Get-Content $projFile.FullName | Write-Host
          Write-Host "=" * 50
        }
      } else {
        Write-Host "SoftwareShow.Contagem.MApp.csproj not found"
        Write-Host "Looking for any .csproj files with 'Contagem' in the name:"
        Get-ChildItem -Recurse -Filter "*Contagem*.csproj" | ForEach-Object {
          Write-Host "Alternative project found: $($_.FullName)"
          Write-Host "Content:"
          Get-Content $_.FullName | Write-Host
        }
      }

- task: DotNetCoreCLI@2
  displayName: 'Build Android APK'
  inputs:
    command: 'publish'
    projects: '**/*Contagem*.csproj'  # Padrão mais amplo para encontrar o projeto
    # Removi o -f para usar o target framework padrão do projeto
    # Ou use net7.0-android se o projeto ainda estiver em .NET 7
    arguments: '-c $(buildConfiguration) -f net7.0-android /p:ApplicationDisplayVersion=1.0 /p:ApplicationVersion=1 /p:AndroidPackageFormat=apk /p:EmbedAssembliesIntoApk=true /p:PublishTrimmed=false'
    publishWebProjects: false
    zipAfterPublish: false

# Tarefa alternativa para encontrar e copiar o APK
- task: CopyFiles@2
  displayName: 'Copy APK to staging directory'
  inputs:
    SourceFolder: '$(Agent.BuildDirectory)'
    Contents: '**/*.apk'
    TargetFolder: '$(Build.ArtifactStagingDirectory)'
    flattenFolders: true

- task: PublishBuildArtifacts@1
  displayName: 'Publish APK artifact'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'android-apk'
    publishLocation: 'Container'